Javascript 实现包含三个部分：
ECMAScript、DOM、BOM



## 1.1 HELLO WORLD

JS 标签需要编写到 script 标签中，位于 head 里

```Js
<script>
// 控制浏览器弹出一个警告框
   alert("Hello World");
// 让计算机在页面中输出一个内容,在body里输出
// 想输出一个换行可以通过"<br>"来实现
   document.write("Hello World");
// 向控制台输出一个内容
   console.log("Hello World");
/* 会弹出一个框用于输入值，输入的值会返回,并且返回的是string
   title是显示给用户的文本
   default指定input框的初始值，此处表示的是default并非是必须的 */
   prompt("title",[default]);
// confirm点击确定返回true，点击取消或按下esc返回false
   result = confirm(question);
</script>
```
alert弹出的这个带有信息的小窗口被称为**模态窗**。“modal” 意味着用户不能与页面的其他部分（例如点击其他按钮等）进行交互，直到他们处理完窗口。在上面示例这种情况下 —— 直到用户点击“确定”按钮。
prompt主要提供的是一个可以输入的窗口
confirm提供的主要是一个确定或者取消
这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。
上述所有方法共有两个限制：
1. 模态窗口的确切位置由浏览器决定。通常在页面中心。
1. 窗口的确切外观也取决于浏览器。我们不能修改它。
这就是简单的代价。还有其他一些方法可以显示更漂亮的窗口，并与用户进行更丰富的交互，但如果“花里胡哨”不是非常重要，那使用本节讲的这些方法也挺好。
## 1.2 JS 编写位置

可以将 js 代码编写到标签的 onclick 属性中
当我们点击按钮时，js 代码才会执行
`<button onclick="alert('press me');">press</button>`
也可以写到 href 标签里
`<a href="javascript:alert('press me');">press</a>`
写在标签的属性中，属于结构和行为耦合，不方便维护
**引入外部 js 标签**
`<script type="text/javascript" src="js/script.js"></script>
script 标签一旦用于引入外部文件，就不能再编写代码了，即使编写浏览器也会忽略
需要再创建一个新的 script 标签用于编写内部代码

## 1.3 基本语法

1. js 中严格区分大小写
1. 每一条语句以分号（;）结尾，虽然不写分号浏览器会自动添加，但是会消耗系统资源，有时候也会加错分号
1. js 中会忽略等多个空格和分号

### 1.3.1 注释

多行注释：`/*里面是注释内容*/`
单行注释：`//`

### 1.3.2 字面量和变量

js 中用 var 来声明一个变量，可以通过,分割，同时声明多个变量
eg：var a;
a = 123;
将声明和赋值同时进行
var a = 123;

### 1.3.3 标识符

可以自主命名的都可以称为标识符
变量名、函数名、属性名都属于标识符
命名一个标识符时需要遵守如下的规则：

1. 标识符中可以含有字母、数字、\_、$
2. 不能以数字开头
3. 不能是 ES 中的关键字或保留字
   @import "picture/关键字.jpg"
4. 标识符一般都采用驼峰命名法
   首字母小写，每个单词的开头字母大写，其余字母小写(helloWorld)
5. js 底层保存标识符时实际上使用 Unicode 编码保存的（UTF-8）

### 1.3.4 代码块

用{}来表示代码块，只有分组作用，没有其他的用途
写在代码块里的东西，外面也可见

## 1.4 数据类型

六种数据类型：String 字符串
Number 数值
Boolean 布尔值
Null 空值
Undefined 未定义
Object 对象

### 1.4.1 字符串

String 字符串

- 在 JS 中字符串需要使用引号引起来
- 引号不能嵌套
  `var str = "hello";`
- 在字符串中可以使用\作为转义字符，当表示一些特殊符号时可以使用\进行转义

```
\" --> "
\' --> '
\n --> 换行
\t --> 制表符
\\  --> \
```

在底层字符串是以字符数组的形式保存的，所以字符串是可以使用length来获取字符串长度的
`charAt()`可以返回字符串中指定位置的字符，可以根据索引获取指定的字符
`indexof()`检索一个字符串中是否含有指定内容，如果有则返回其第一次出现的索引，如果没有则返回-1。可以通过指定第二个参数来指定开始查找的位置
`lastIndexof()`和indexof一样，只不过其是从后往前找，indexof是从前往后找
`slice()`可以从字符串中截取指定的内容，不会影响原字符串，而是将截取到内容返回
`split("xxx")`将一个字符串拆分为一个数组，需要一个字符串作为参数，会根据该字符串去拆分数组
`toUpperCase`将一个字符串转换为大写并返回
`toLowerCase`将一个字符串转换为小写并返回
~~还有好多，但是感觉用处不大~~

### 1.4.2 number

- 整数和浮点数都是 Number 类型
- 可以使用 typeof 来检查一个变量的类型
  typeof 变量（typeof a）
- js 中可以表示的数字的最大值（Number.MAX_VALUE）
  有一个大于 0 的最小值（Number.MIN_VALUE）
- 如果使用 Number 表示的数字超过了最大值，则会返回一个 Infinity
- NaN --> NOT A NUMBER 特殊的数字，非法数字
- 使用 JS 进行浮点运算，可能得到一个不精确的结果
  所以不要使用 js 进行精确度要求比较高的运算

### 1.4.3 布尔值（Boolean）

布尔值只有两个（true、false）
var bool = true;

### 1.4.4 NULL 和 undefined

Null 类型的值只有一个，就是 null
null 专门用来表示一个为空的对象
使用 typeof 检查一个 null 值时，会返回 object

undefined；类型的值只有一个，就是 undefined
当声明一个变量，但是并不给变量赋值时，他的值就是 undefined
使用 typeof 检查 undefined 时，会返回 undefined

### 1.4.5 强制类型转换

#### 1.4.5.1 string

将一个数据类型强制转换为 string
方式一:调用被转换数据类型的 toString()方法`a.toString();`
不会影响到原变量，他会将转换的结果返回
null 和 undefined 这两个值没有 tostring 方法
方式二：调用 String()函数，并将被转换的数据作为参数传递给函数`a=String(a);`

#### 1.4.5.2 number

方式一：使用 Number()函数

1. 如果是纯数字的字符串，则直接将其转换为数字
1. 如果字符串中有非数字的内容，则转换为 NaN
1. 如果字符串是一个空串或者是一个全是空格的字符，则转换为 0
1. bool 值转换，true 为 1，false 为 0
1. null 转换为 0
1. undefined 转换为 NaN

方式二：专门用来对字符串使用，对于非 string 使用这两个函数，会将其先转换为 string 再进行操作
parseInt() 转换为整数。将一个字符串中的有效的整数内容取出来，然后转换为 number
parseFloat()可以获得有效的小数。
局限性很大，一旦碰到非数字类型就停止截取了。

#### 1.4.5.3 bool

调用 Boolean()函数
数字转为 bool，除了 0 和 NaN，其余全是 true
字符串除了空串，其余全是 true
null 和 undefined 转换为 false

#### 1.4.5.4 进制

16 进制数字需要以 0x 开头`a=0xff;`
8 进制数字以 0 开头`a=070;`
2 进制数字以 0b 开头，兼容性不好
像“070”这种字符串，有些浏览器会当成 8 进制解析，有些会当成 10 进制解析
可以通过参数来限制`a=parseInt(a,10);`

### 1.4.6 运算符

- typeof 用来获得一个值的类型，他会将该值的类型以字符串形式返回
- 算数运算符进行运算时，如果是非 number 类型，会将其转换为 number 类型进行运算，只有加法存在例外
- 如果对两个字符串进行加法运算，会对两个字符串进行拼串操作，即拼接为一个字符串并返回。
  任何值和字符串相加，都会转换为字符串进行操作
  可以利用这一特点，将任意数据类型+""即可将其转换为 string
- 可以通过为一个值-0 *1 /1 将值转换为 number
- %取余操作
- a**b求幂操作，将a提升至a的b次幂

#### 1.4.6.1 一元运算符

+，对值无影响 -，对值取反`a = -a;`
对于非 number 类型的值，可以将其转换为 number 再进行计算。
所以可以对非 number 类型的值，可以将其加一个+号将其转换为 number 类型

#### 1.4.6.2 自增自减

自增++
其分为两种，后++(a++)和前++(++a)，但是 a++和++a 的值不同。每次只自增 1
a++的值等于原变量的值（自增前的值）
++a 的值等于新值（自增后的值）

```js
a = 20;
result = a++ + ++a + a;
// result = 20 + 22 + 22
// 因为a++是原值，所以a++等于20，这时a变为了21，再经过++a，++a变为22，a变为22
// 所以result = 64
```

自减--
其分为两种，后--（a--）和前--（--a），都会使值立刻自减 1，但是两者值不同
a--等于原值
--a 等于新值

#### 1.4.6.3 逻辑运算符

- ！ 非 对一个布尔值进行取反操作
  可以将任意数据类型做两次非运算，将其转换为布尔值
- && 与 都真为真，一假为假(只要有一个 false，则返回 false，只有两个值都为 true，才返回 true)
  js 中的与为短路的“与”，如果第一个值为 false，则不会检查第二个值。
- || 或 一真为真
  如果第一个值为 true，则不会检查第二个值
- 对于非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，并且会返回原值
  **与运算：**如果两个值都为 true，则返回后面的
  如果两个值中有 false，则返回靠前的 false
  **如果第一个值为 true，则必然返回第二个值**
  **如果第一个值为 false，则必然返回第一个值**
  **或运算：如果第一个值为 true，则直接返回第一个值**
  **如果第一个值为 false，则直接返回第二个值**

#### 1.4.6.4 赋值运算符

= 将符号右侧的值赋值给符号左侧的变量
+= a+=5 等价于 a = a + 5
-= a-=5 等价于 a = a -5
同理还有\*=和/=和%=

#### 1.4.6.5 关系运算符

通过关系运算符可以比较两个值之间的大小关系，如果关系成立，返回 true，不成立则返回 false
`> < >= <=`
任何值和 NaN 做任何比较都是 false
如果符号两侧的值都是字符串时，不会将其转换为数字进行比较，比较的是字符串的字符编码，并且是一位一位进行比较，如果两位一样，则比较下一位
所以可以借用他来对英文进行排序
如果比较的两个字符串型的数字，可能会得到不可预期的结果
在比较两个字符串型的数字时，一定要转型

#### 1.4.6.6 相等运算符

比较两个值是否相等，相等会返回 true，否则返回 false
使用==来做相等运算
使用==来比较两个值时，会将其转换成相同的类型进行转换
undefined 衍生自 null，所以这两个值做相等判断时，会返回 true
NaN 不和任何值相等，包括他本身
可以通过 isNaN()函数来判断一个数是不是 NaN，如果是 NaN 返回 true，不是则返回 false
!=不相等运算，不相等则为 true，会做类型转换
===全等，用来判断两个值是否全等，如果不同，则为 false。而且它不会做自动的类型转换

#### 1.4.6.7 条件运算符

条件表达句?语句 1:语句 2;
条件运算符在执行时，首先对条件表达式进行求值
如果该值为 true，则执行语句 1，并返回执行结果
如果该值为 false，则执行语句 2，并赶回执行结果

```js
var a = 300;
var b = 143;
var c = 50;
// 求abc中的最大值
// 如果a>b，则返回前面的式子，即a和c再做比较，a>c则返回a，a<c则返回c
// 同理，a<b，则返回后面的式子，b和c再做比较
var max = a > b ? (a > c ? a : c) : b > c ? b : c;
console.log("max=" + max);
```

~~比较奇怪，为啥不用 if，用这东西~~

#### 1.4.6.8 运算符的优先级

@import "picture/运算符.jpg"
从上向下优先级递减，如果优先级相同，则从左往右计算。
可以通过()来改变优先级

## 1.5 流程控制语句

### 1.5.1 if

if 只能控制紧随其后的语句，所以想要控制多条语句，需要放到代码块里

```js
if (条件表达式) {
}
```

if...else... true 则执行 if，false 则执行 else

```js
if(){

}else if{

}else if{

}
```

### 1.5.2 switch

```js
switch(条件表达式){
  case 表达式:
  语句...
  break;
  case 表达式:
  语句...
  break;
  default:
  语句...
  break;
}
```

通过全等操作进行比较，千万记得加 break，要不就会一直执行...,会从符合条件的地方开始执行，一直执行下去，必须用 break 停止
如果所有的比较结果都为 false，则只执行 default 后的语句

### 1.5.3 while

while 会先对条件表达式进行求值判断，如果值为 true，则执行循环体，
直到值为 false，停止循环
可以使用 break 来终止循环
do{语句...}while(条件表达式)
do...while 语句在执行时，会先执行循环体，循环体执行完毕后，会对 while 的条件表达式进行判断，如果为 true 则继续循环，false 则退出
和 while 的区别就是，while 是先判断再执行，do...while 是先执行再判断
do...while 可以保证循环体至少执行一次

### 1.5.4 for

for(初始化表达式;条件表达式;更新表达式){
语句...
}
for 循环中的三个部分都可以省略，也可以写在外部

### 1.5.5 forEach()
增强for循环，forEach需要一个回调函数作为参数，回调函数的形参分别是value：遍历的数组内容；index：对应的数组索引；array：数组本身。
`arr.forEach(function(value,index,array){})`

## 1.6 对象

基本数据类型都是单一的值，值和值之间没有任何的联系
对象属于一种复合的数据类型（引用数据类型），在对象中可以保存多个不同数据类型的属性

对象的分类：

1. 内建对象：由 ES 标准中定义的对象，在任何的 ES 的实现中都可以使用
1. 宿主对象：由 JS 的运行环境提供的对象，目前来讲主要指由浏览器提供的对象
1. 自定义对象： 由开发人员自己创建的对象

### 1.6.1 对象的基本操作

使用 new 关键字调用的函数，是构造函数(construcor)
构造函数是专门用来创建对象的函数
使用 typeof 检查一个对象时，会返回 object
`var obj = new Object();`
在对象中保存的值称为属性
向对象中添加属性：对象.属性名 = 属性值

```js
obj.name = "xxx";
obj.gender = "xx";
obj.age = "18";
```

读取对象中的属性： 对象.属性名
修改对象中的属性： 对象.属性名=新值
删除对象的属性： delete 对象.属性名

### 1.6.2 属性名和属性值

对象的属性名不强制要求遵守标志符的规范
如果要使用特殊的属性名，不能采用.的方式来操作，需要使用`对象["属性名"] = 属性值`，读取时也需要采用这种方法
使用[]这种形式去操作属性，更加的灵活
在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性
JS 对象的属性值，可以使任意的数据类型，甚至也可以是一个对象

in 运算符，通过该运算符可以检查一个对象中是否含有指定的属性
如果有则返回 true，没有则返回 false`"属性名" in 对象`

### 1.6.3 堆和栈

JS 中的变量都是保存到栈内存中的。
基本数据类型的值直接在栈内存中存储，值与值之间独立存在，修改一个变量不会影响其他的变量
对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟一个新的空间存储
而栈内存中存储的是对象的内存地址，如果两个变量保存的是同一个对象引用，当一个变量修改对象的属性时，另一个也会受到影响

比较两个基本数据类型的值时，就是比较值
但是比较两个引用数据类型时，其比较的是对象的内存地址
即时两个对象是一模一样的，但是地址不同，他也会返回 false

### 1.6.4 对象字面量

使用对象字面量，可以在创建对象时，直接指定对象中的属性

```js
var obj = {
  name: "xxx",
  age: 28,
  gender: "man",
};
```

属性名和属性值是一组一组的名值对结构，名和值之间使用:连接，多个变量名之间用,隔开。

## 1.7 函数

函数也是一个对象
函数中可以封装一些功能，在需要时可以执行这些功能
`var fun = new Function();`
函数中的代码会在函数调用的时候执行
调用函数时，函数中封装的代码会按照顺序执行
调用方法：`fun();`

**使用函数声明来创建一个函数**
语法：

```js
     function 函数名([形参1,形参2,...形参N]){
       语句...
     }
```

### 1.7.1 函数的参数

声明形参相当于在函数内部声明了对应的变量
在调用函数时，可以在()中指定实参(实际参数)

```js
function sum(a, b) {
  console.log(a + b);
}

sum(1, 2);
```

调用函数时解析器不会检查实参的类型，所以要注意非法参数。
调用参数时，解析器也不会检查实参的数量
多余实参不会被赋值
如果实参的数量少于形参的数量，则没有对应实参的形参将是 undefined

如果参数过多时，可以将参数封装到一个对象中，通过对象传递

实参也可以是一个函数

```js
// 假设有一个函数叫做fun
// 相当于直接使用函数对象
fun;
// 相当于使用的函数的返回值，属于调用函数
fun();
```

### 1.7.2 函数的返回值

可以使用 return 来设置函数的返回值
return 后的值将作为函数的执行结果返回，可以定义一个变量，来接收该结果
如果 return 语句后不跟任何值相当于返回 undefined

使用 break 可以退出当前循环
使用 continue 可以跳过当次循环
使用 return 可以结束整个函数

函数返回值可以是任意类型

### 1.7.3 立即执行函数

函数定义完，立即被调用，立即执行函数往往只会执行一次
语法：`(function(){})`
也就是在括号里套一个函数

### 1.7.4 方法

函数也可以成为对象的属性
如果一个函数作为一个对象的属性保存
我们称这个函数是这个对象的方法
调用函数就说调用对象的方法(method)
其只是名称上的区别

通过 for...in 语句可以枚举对象中的属性
for...in 语句会循环遍历后面的值并赋值给前面的变量
所以每次循环，变量的值都会改变

```js
var obj={
  name="wu";
  age="22";
  gender="man";
  address="nothing";
};
for(var n in obj){
  console.log(n);
}
// 输出结果为name、age、gender、address
```

### 1.7.5 作用域

作用域指一个变量的作用的范围
在 js 中一共有两种作用域

1. 全局作用域：直接编写在 script 标签中的 js 代码，都在全局作用域中
   全局作用域在页面打开时创建，在页面关闭时销毁
   在全局作用域中有一个全局对象 window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用
   在全局作用域中，创建的变量都会作为 window 对象的属性保存
   函数其实就是 window 对象的方法

   使用 var 关键字声明的变量，会在所有代码执行前被声明，即在代码开始时就已经声明了这些变量，但是不会被赋值

   使用函数声明形式创建的函数 function 函数(){} ，会在代码执行前被声明

1. 函数作用域：调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁
   每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的
   在函数中可以访问到全局作用域的变量
   当在函数作用域中寻找变量时，会首先在自身作用域中寻找，如果没有则向上一级作用域中寻找，直到找到全局作用域中为止，没有则报错

### 1.7.6 this

解析器在调用函数时每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是 this
this 指向的是一个对象，这个对象我们称为函数执行的上下文对象，
根据函数的调用方法不同，this 会指向不同的对象

1. 以函数的形式调用时，this 永远都是指向 window
1. 以方式的形式调用时，this 就是调用方法的那个对象
   所以可以通过 this 来调用不同对象中的相同命名的变量

### 1.7.7 使用工厂方法创建对象

```js
function createPersn(name, age, gender) {
  var obj = new Object();
  obj.name = name;
  obj.age = age;
  obj.gender = gender;
  obj.sayName = function () {
    alert(this.name);
  };
  return obj;
}
```

使用工厂方法构造的函数都是 object 属性，所以还是有点问题的

### 1.7.8 构造函数

构造函数是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写

构造函数和普通函数的区别就是调用方式的不同
普通函数是直接调用，构造函数需要用 new 关键字来调用

构造函数的执行流程：

1. 立刻创建一个新的对象
2. 将新建的对象设置为函数中 this
3. 逐行执行函数中的代码
4. 将新建的对象作为返回值返回

使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类
将通过一个构造函数创建的对象，称为是该类的实例

使用 instanceof 可以检查一个对象是否是一个类的实例（对象 instanceof 构造函数）
如果是则返回 true，否则则为 false

**所有的对象都是 object 的后代，所以任何对象和 object 做 instanceof 都会返回 true**

```js
function Person(name, age, gender) {
  this.name = name;
  this.age = age;
  this.gender = gender;
  // 向对象中添加一个方法
  this.sayName = function () {
    alert(this.name);
  };
}

var per = new Person("wu", "11", "man");
// per就是person的实例
```

在上面的 Person 构造函数中，为每一个对象都添加了一个 sayName 方法，因为其方法是在构造函数内部创建的
也就是构造函数每执行一次就会创建一个新的方法，每个方法都不相同，但是完全没必要
可以使所有的对象共享同一个方法，但是如果将函数定义在全局作用域中，会污染全局作用域的命名空间
而且定义在全局作用域中也很不安全

### 1.7.9 原型对象

每创建一个函数，解析器都会向函数中添加一个属性 prototype
这个属性对应着一个对象，这个对象就是原型对象
如果函数作为普通函数调用 prototype 没有任何作用
当函数通过构造函数调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，可以通过**proto**来访问该属性

原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象
所以可以将共有的东西设置到这个原型对象中，从而达成共用的目的。

因为在访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有就会去原型对象中寻找，如果找到则直接使用
如果仍然没有则去原型的原型中寻找，直到找到 Object 的原型
`Person.prototype.a = 123;`向 person 的原型中添加属性 a
`Person.prototype.SayHello = function(){}`向 person 的原型中添加 sayhello 方法

**所以在创建构造函数时，可以将共有的属性和方法添加到 prototype 中，达到共同使用的目的**

可以使用 in 来检查对象中是否含有某个属性，如果对象中没有但是原型中有，也会返回 true

可以使用对象的 hasOwnProperty()来检查对象自身中是否含有该属性
使用该方法只有当对象自身中含有属性时，才会返回 true

当直接打印某一个对象时，实际输出的是对象的 toString()方法
所以如果想要直接显示或者有别的用途的话，需要修改 toString()方法来完成，当然修改的是原型对象里的方法

### 1.7.10 call和apply
这两个方法都是函数对象的方法，需要通过函数对象来调用
当对函数调用call()和apply()时，可以将一个对象指定为第一个参数
此时这个对象将会成为函数执行时的this
call()方法可以将实参在对象之后依次传递
apply()方法需要将实参封装到一个数组中统一传递
### 1.7.11 arguments
在调用函数时，浏览器每次都会传递进两个隐含的参数：
1. 函数的上下文对象this
1. 封装实参的对象arguments
arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度
在调用函数时，我们所传递的实参都会在arguments中保存
arguments.length可以用来获取实参的长度
即使不定义形参，也可以通过arguments来使用实参

## 1.8 垃圾回收（GC）

当一个对象没有任何的变量或属性对他进行引用，此时我们将会永远无法操作该对象
此时这种对象就是一个垃圾，需要进行清理
JS 中具有自动垃圾回收机制，会自动将这些垃圾对象从内存中销毁
所以需要将不再使用的对象设置为 null 即可

## 1.9 数组(array)

- 数组也是一个对象
- 索引：从 0 开始的整数
- 数组通过使用数字来作为索引操作元素
- `var arr = [];`构造数组
- 数组中的元素可以是任意的数据类型
- 数组中放数组，称为二维数组

- 可以使用 length 属性来获取数组的长度（元素的个数） 数组.length
- 对于非连续的数组，使用 length 会获得数组的最大的索引+1
- 修改length会改变数组的长度，如果数组超出length长度会被截掉

### 1.9.1 数组的方法
方法 | 用法
------------ | -------------
push() | 向数组的末尾添加一个或多个元素，并返回数组的新长度
pop() | 删除数组的最后一个元素，并将被删除的元素作为返回值返回
shift() | 删除数组的第一个元素，并将被删除的元素作为返回值返回
unshift() | 向数组开头添加一个或多个元素，并返回新的数组长度。<br> 向前边插入元素后，其他的元素索引会依次调整
forEach() | 这个数组只支持IE8以上的浏览器。<br> 这个方法用来遍历数组 <br> 这个方法需要一个函数作为参数，但是这种函数由我们创建但是不由我们调用，称为回调函数，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，可以通过定义形参，来读取这些内容。 <br> 浏览器会在回调函数中传递三个参数：<br> 1. 当前正在遍历的元素。 <br> 2. 正在遍历的元素的索引。 <br> 3. 正在遍历的数组
**slice()** | 可以从数组中提取出指定元素。 <br> 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回 <br> 需要有截取开始的位置的索引和截取结束的位置的索引，左闭右开，即左边包含，右边不包含。<br> 如果第二个参数省略不写，则表示从某位置开始直到最后 <br> 第二个参数可以是负数，表示倒着删
**splice()** | 可以从数组中删除指定元素，其会影响到原数组，会将指定元素从原数组中删除，并将被删除的元素怒作为返回值返回 <br> 有两个参数，表示开始位置的索引，表示删除的数量，如果有第三个及以后，则可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边
concat() | 连接两个或多个数组，并将新的数组返回。该方法不会对原数组产生影响
join("连接符") | 该方法可以将数组转换为一个字符串，该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回 <br> 并且可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符，如果不指定连接符，则默认使用,作为连接符
reverse() | 该方法可以用来反转数组，会对原数组产生影响
sort() | 可以用来对数组中的元素进行排序，也会影响原数组，默认会按照Unicode编码进行排序，即时对于纯数字的数组，也会按照Unicode编码来排序，所以可能会得到错误的结果。<br> 可以添加一个回调函数来指定排序规则，回调函数需要定义两个形参，如果返回值大于0，则交换；小于0则不变；等于0，则认为相等，也不交换位置。
```js
arr.sort(function(a,b)){
  // 升序排列
  return a-b;
  // 降序排列
  return b-a;
}
```
## 1.10 date和math
通过date对象来表示时间
如果直接使用构造函数创建一个date对象，则会封装为当前代码执行的时间 `var d = new Date();`
创建一个指定的时间对象需要在构造函数中传递一个表示时间的字符串作为参数（格式：月/日/年 时:分:秒）
~~感觉这玩意没啥用，用的时候百度完事儿了~~
getTime() 获取当前日期对象的时间戳，从格林威治标准时间开始，以ms为单位
`time = Date.now()`获取当前的时间戳，可以利用时间戳来测试代码的执行性能
也可以用time()和timeEnd()来计算代码执行时间

math里封装了数学运算相关的属性和方法
比如`Math.abs(-1)`就是求绝对值
`Math.ceil()`对一个小数向上取整
`Math.floor()`向下取整
`Math.random()`生成一个0-1之间的随机数
`Math.max()`最大值
`Math.min()`最小值
`Math.squrt()`开方

## 1.11 包装类
通过包装类可以将基本数据类型的数据转换为对象
String()
Number()
Boolean()
实际应用中不会使用基本数据类型作为对象

## 1.12 正则表达式
用于定义一些字符串的规则，计算机可以根据正则表达式，来检查一个字符串是否符合规则。
或者将字符串中符合规则的内容提取出来。
语法：`let 变量 = new RegExp("正则表达式","匹配模式");`
使用test()来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false
在构造函数中可以传递一个匹配模式作为第二个参数，可以是`i`表示忽略大小写,`g`表示全局匹配模式
### 1.12.1 正则语法
使用字面量来创建正则表达式
语法：`let 变量 = /正则表达式/匹配模式`
使用字面量的方式创建更加简单，使用构造函数创建更加灵活

使用 | 表示或者的意思。`reg = /a|b|c/;`表示a或b或c
或者使用`[]`表示也可以，`[]`里的内容也是或的关系。`[ab] == a|b`,`[a-z] 任意小写字母`,`[A-Z] 任意大写字母`,`[A-z] 任意字母`
`[^]`这种形式表示的是除了，比如`[^0-9]`就是去除任意数字